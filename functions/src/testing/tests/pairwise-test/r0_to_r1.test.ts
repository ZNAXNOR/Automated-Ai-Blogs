/**
 * Pairwise Chain Test: R0 â†’ R1
 *
 * Ensures that the output of Round0 (trend normalization/deduplication)
 * can be directly consumed by Round1 (ideation) without schema mismatch
 * or invalid data breaking the pipeline.
 */

import { _test as R0 } from "../../../rounds/r0_trends";
import { Round1_Ideate as runRound1, IdeationItem } from "../../../rounds/r1_ideate";
import admin from "firebase-admin";
import fetch, { Response } from "node-fetch";

jest.mock("node-fetch", () => jest.fn());
const mockedFetch = fetch as unknown as jest.MockedFunction<typeof fetch>;

// --- Firestore Mock (same as r1.test.ts) ---
const setMock = jest.fn();
const getMock = jest.fn();
const docMock: jest.Mock = jest.fn();
const collectionMock: jest.Mock = jest.fn(() => ({ doc: docMock }));
docMock.mockImplementation(() => ({
  get: getMock,
  set: setMock,
  collection: collectionMock,
}));

const firestoreMock = {
  collection: collectionMock,
  doc: docMock, // This is the fix
};

const firestoreFuncWithStatics = jest.fn(() => firestoreMock) as any;
firestoreFuncWithStatics.FieldValue = {
  serverTimestamp: jest.fn(() => "MOCK_SERVER_TIMESTAMP"),
};
// --- End Firestore Mock ---

describe("Pairwise: R0 -> R1", () => {
  const runId = "pairwise-test-run";

  beforeEach(() => {
    jest.clearAllMocks();

    Object.defineProperty(admin, "firestore", {
      get: () => firestoreFuncWithStatics,
      configurable: true,
    });

    process.env.HUGGINGFACE_API_KEY = "test-key";
    process.env.HUGGINGFACE_MODEL = "test-model";
  });

  test("R0 output feeds correctly into R1 ideation", async () => {
    // Step 1: Run R0 deterministically
    const buckets = [
      {
        type: "autocomplete" as const,
        sourceName: "serp:autocomplete",
        items: [
          "Apple iPhone 16 launch date?",
          "OpenAI o3 mini",
          "Remote work productivity",
        ],
      },
      {
        type: "rss" as const,
        sourceName: "rss:theverge",
        items: ["AI in healthcare"],
      },
    ];
    const { items: r0Trends, sourceCounts } = R0.deterministicProcess(buckets);

    // Step 2: Mock Firestore get to return R0 trends
    getMock.mockResolvedValue({
        exists: true,
        data: () => ({ items: r0Trends, cached: false, sourceCounts })
    });

    // Step 3: Dynamically generate the mock LLM API response
    // This ensures the 'trend' keys in the mock response EXACTLY match
    // the normalized 'query' properties generated by r0_trends.
    const fakeModelOutputData = r0Trends.map(trendItem => {
      let ideas;
      if (trendItem.query.includes("iphone")) {
          ideas = ["iPhone 16: Everything We Know So Far", "The iPhone 16 Camera: A Photographer\'s Dream?", "Is the iPhone 16 Worth the Upgrade?"];
      } else if (trendItem.query.includes("openai")) {
          ideas = ["OpenAI\'s New o3 Mini: A Tiny AI Powerhouse", "What Can the o3 Mini Do? First Impressions", "o3 Mini vs. The Competition: A Detailed Comparison"];
      } else if (trendItem.query.includes("remote")) {
          ideas = ["The Ultimate Guide to Remote Work Productivity", "Staying Focused and Motivated While Working from Home", "The Best Tools for Remote Teams in 2025"];
      } else { // "ai in healthcare"
          ideas = ["How AI is Revolutionizing Medical Diagnostics", "The Ethical Dilemmas of AI in Healthcare", "Patient Care in the Age of Artificial Intelligence"];
      }
      return {
          trend: trendItem.query, // Use the ACTUAL normalized query as the key
          ideas: ideas
      };
    });

    const fakeModelOutput = JSON.stringify(fakeModelOutputData);

    const mockResponse = {
      ok: true,
      status: 200,
      json: async () => JSON.parse(fakeModelOutput),
      text: async () => fakeModelOutput,
      headers: { get: () => "application/json" },
    } as unknown as Response;
    mockedFetch.mockResolvedValue(mockResponse);

    // Step 4: Run R1 using R0\'s output
    await runRound1(runId);

    // Step 5: Assertions
    expect(setMock).toHaveBeenCalledTimes(1);
    const [writtenData] = setMock.mock.calls[0];
    const items = writtenData.items as IdeationItem[];

    // Schema checks
    expect(items.length).toBe(12);
    const trendQueries = r0Trends.map(t => t.query);
    expect(trendQueries).toContain("ai in healthcare"); // This is the fix

    for (const item of items) {
      expect(item.trend).toEqual(expect.any(String));
      expect(item.idea).toEqual(expect.any(String));
      expect(item.idea.trim().length).toBeGreaterThan(0);
    }
  }, 10000);
});
