## 🧩 r2_angle_storage.md

### **Purpose**

Implements the **storage integration** for the **R2 Angle flow**, responsible for generating and storing content “angles” derived from the previous discussion phase.
This round introduces a **traceable inline subflow** for storage within the main R2 flow — not a separate file — ensuring the Genkit UI shows it as an independent trace segment under the same pipeline.

---

### **🏗️ Storage Architecture**

#### **Firestore (fs)**

* Updates the **existing topic document** created in **R0** and updated in **R1**.
* Adds or overwrites a new field `r2` within the same topic document path:

  ```
  topics/{topicId}/
    ├── metadata/
    ├── r0/
    ├── r1/
    ├── r2/
  ```
* The `r2` node contains structured JSON of the current round’s output and a reference to its corresponding GCS file.

#### **Google Cloud Storage (gcs)**

* Stores the full JSON output of the R2 flow.
* File path pattern:

  ```
  gs://ai-blog-bucket/topics/{topicId}_r2.json
  ```
* This path is referenced from the `r2` node in Firestore for cross-link consistency.

---

### **⚙️ Implementation Details**

The R2 flow now includes a **traceable inline subflow** that handles Firestore and GCS operations.

#### **Inline Subflow Signature**

```ts
const r2_storage_result = await ai.runFlow("r2_storage_inline", async () => {
  const topicId = topicData.id;
  const r2Data = {
    ...angleOutput,
    createdAt: new Date().toISOString(),
  };

  // --- Save to GCS ---
  const gcsFilePath = `topics/${topicId}_r2.json`;
  const gcsRef = await gcsClient.saveJSON(gcsFilePath, r2Data);

  // --- Update Firestore ---
  const fsPath = `topics/${topicId}`;
  await firestoreClient.updateDocument(fsPath, {
    r2: {
      data: r2Data,
      storageRef: gcsRef,
      updatedAt: new Date().toISOString(),
    },
  });

  // --- Return storage metadata ---
  return {
    fsPath,
    gcsRef,
    r2Data,
  };
});
```

#### **Main Flow Integration**

```ts
const r2_angle_output = await ai.runFlow("r2_angle_flow", async () => {
  const topicData = await firestoreClient.getDocument(`topics/${topicId}`);

  // Generate angle data
  const angleOutput = await generateAngles(topicData);

  // Inline subflow for traceable storage
  const storageResult = await ai.runFlow("r2_storage_inline", async () => {
    const gcsFilePath = `topics/${topicData.id}_r2.json`;
    const gcsRef = await gcsClient.saveJSON(gcsFilePath, angleOutput);
    const fsPath = `topics/${topicData.id}`;
    await firestoreClient.updateDocument(fsPath, {
      r2: {
        data: angleOutput,
        storageRef: gcsRef,
        updatedAt: new Date().toISOString(),
      },
    });
    return { fsPath, gcsRef };
  });

  return {
    topicId: topicData.id,
    angleData: angleOutput,
    storage: storageResult,
  };
});
```

---

### **🧱 Expected Firestore Structure Example**

```json
{
  "id": "topic_12345",
  "metadata": { "title": "AI in Marketing", "slug": "ai-in-marketing" },
  "r0": { "summary": "...", "storageRef": "gs://ai-blog-bucket/topics/topic_12345_r0.json" },
  "r1": { "discussion": "...", "storageRef": "gs://ai-blog-bucket/topics/topic_12345_r1.json" },
  "r2": {
    "angles": [...],
    "storageRef": "gs://ai-blog-bucket/topics/topic_12345_r2.json",
    "updatedAt": "2025-10-28T12:00:00.000Z"
  }
}
```

---

### **✅ Return Object (to Main Pipeline)**

```ts
{
  topicId: string;
  angleData: object;
  storage: {
    fsPath: string;
    gcsRef: string;
  };
}
```

---

### **📋 Notes**

* Uses same **Firestore and GCS adaptors** (`firebase.firestore.client.ts`, `firebase.gcs.client.ts`).
* The inline `ai.runFlow('r2_storage_inline')` ensures the Genkit UI shows it as a **separate, traceable node**.
* Maintain topic continuity: the same `topicId` should persist through all rounds (R0 → R1 → R2 → ...).
* File is self-contained and production-ready for integration into your existing Genkit-based flow pipeline.