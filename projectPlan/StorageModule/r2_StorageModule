## ðŸ§© r2_angle_storage.md

### **Purpose**

Implements the **storage integration** for the **R2 Angle flow**, responsible for generating and storing content â€œanglesâ€ derived from the previous discussion phase.
This round introduces a **traceable inline subflow** for storage within the main R2 flow â€” not a separate file â€” ensuring the Genkit UI shows it as an independent trace segment under the same pipeline.

---

### **ðŸ—ï¸ Storage Architecture**

#### **Firestore (fs)**

* Updates the **existing topic document** created in **R0** and updated in **R1**.
* Adds or overwrites a new field `r2` within the same topic document path:

  ```
  topics/{topicId}/
    â”œâ”€â”€ metadata/
    â”œâ”€â”€ r0/
    â”œâ”€â”€ r1/
    â”œâ”€â”€ r2/
  ```
* The `r2` node contains structured JSON of the current roundâ€™s output and a reference to its corresponding GCS file.

#### **Google Cloud Storage (gcs)**

* Stores the full JSON output of the R2 flow.
* File path pattern:

  ```
  gs://ai-blog-bucket/topics/{topicId}_r2.json
  ```
* This path is referenced from the `r2` node in Firestore for cross-link consistency.

---

### **âš™ï¸ Implementation Details**

The R2 flow now includes a **traceable inline subflow** that handles Firestore and GCS operations.

#### **Inline Subflow Signature**

```ts
const r2_storage_result = await ai.runFlow("r2_storage_inline", async () => {
  const topicId = topicData.id;
  const r2Data = {
    ...angleOutput,
    createdAt: new Date().toISOString(),
  };

  // --- Save to GCS ---
  const gcsFilePath = `topics/${topicId}_r2.json`;
  const gcsRef = await gcsClient.saveJSON(gcsFilePath, r2Data);

  // --- Update Firestore ---
  const fsPath = `topics/${topicId}`;
  await firestoreClient.updateDocument(fsPath, {
    r2: {
      data: r2Data,
      storageRef: gcsRef,
      updatedAt: new Date().toISOString(),
    },
  });

  // --- Return storage metadata ---
  return {
    fsPath,
    gcsRef,
    r2Data,
  };
});
```

#### **Main Flow Integration**

```ts
const r2_angle_output = await ai.runFlow("r2_angle_flow", async () => {
  const topicData = await firestoreClient.getDocument(`topics/${topicId}`);

  // Generate angle data
  const angleOutput = await generateAngles(topicData);

  // Inline subflow for traceable storage
  const storageResult = await ai.runFlow("r2_storage_inline", async () => {
    const gcsFilePath = `topics/${topicData.id}_r2.json`;
    const gcsRef = await gcsClient.saveJSON(gcsFilePath, angleOutput);
    const fsPath = `topics/${topicData.id}`;
    await firestoreClient.updateDocument(fsPath, {
      r2: {
        data: angleOutput,
        storageRef: gcsRef,
        updatedAt: new Date().toISOString(),
      },
    });
    return { fsPath, gcsRef };
  });

  return {
    topicId: topicData.id,
    angleData: angleOutput,
    storage: storageResult,
  };
});
```

---

### **ðŸ§± Expected Firestore Structure Example**

```json
{
  "id": "topic_12345",
  "metadata": { "title": "AI in Marketing", "slug": "ai-in-marketing" },
  "r0": { "summary": "...", "storageRef": "gs://ai-blog-bucket/topics/topic_12345_r0.json" },
  "r1": { "discussion": "...", "storageRef": "gs://ai-blog-bucket/topics/topic_12345_r1.json" },
  "r2": {
    "angles": [...],
    "storageRef": "gs://ai-blog-bucket/topics/topic_12345_r2.json",
    "updatedAt": "2025-10-28T12:00:00.000Z"
  }
}
```

---

### **âœ… Return Object (to Main Pipeline)**

```ts
{
  topicId: string;
  angleData: object;
  storage: {
    fsPath: string;
    gcsRef: string;
  };
}
```

---

### **ðŸ“‹ Notes**

* Uses same **Firestore and GCS adaptors** (`firebase.firestore.client.ts`, `firebase.gcs.client.ts`).
* The inline `ai.runFlow('r2_storage_inline')` ensures the Genkit UI shows it as a **separate, traceable node**.
* Maintain topic continuity: the same `topicId` should persist through all rounds (R0 â†’ R1 â†’ R2 â†’ ...).
* File is self-contained and production-ready for integration into your existing Genkit-based flow pipeline.